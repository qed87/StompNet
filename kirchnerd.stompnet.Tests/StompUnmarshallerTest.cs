using System.Collections.Generic;
using System.Linq;
using System.Threading;
using kirchnerd.StompNet.Exceptions;
using kirchnerd.StompNet.Internals.Transport;
using kirchnerd.StompNet.Internals.Transport.Frames;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace kirchnerd.StompNet.Tests;

[TestClass]
public class StompUnmarshallerTest
{
    [TestMethod]
    public void Given_a_valid_stream_of_bytes_When_Unmarshall_Than_frames_should_be_correctly_read()
    {
        /*
         * CONNECTED EOL
         * heart-beat: 0,0 EOL
         * session:1 EOL
         * version:1.1 EOL
         * EOL
         * NULL
         * RECEIPT EOL
         * receipt-id:1 EOL
         * EOL
         * NULL
         * MESSAGE EOL
         * destination:test EOL
         * message-id:5 EOL
         * subscription-id:a EOL
         * EOL
         * Test Test TestNULL
         */
        var stream = new Stack<byte>(new byte[]
        {
            0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x45, 0x44, 0x0a, 0x68, 0x65, 0x61, 0x72, 0x74, 0x2d, 0x62, 0x65, 0x61, 0x74, 0x3a, 0x30, 0x2c, 0x30, 0x0a, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x31, 0x0a, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x31, 0x2e, 0x31, 0x0a, 0x0a, 0x00, 0x0a, 0x52, 0x45, 0x43, 0x45, 0x49, 0x50, 0x54, 0x0a, 0x72, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x2d, 0x69, 0x64, 0x3a, 0x31, 0x0a, 0x0a, 0x00, 0x0a, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x0a, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x74, 0x65, 0x73, 0x74, 0x0a, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2d, 0x69, 0x64, 0x3a, 0x35, 0x0a, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x2d, 0x69, 0x64, 0x3a, 0x61, 0x0a, 0x0a, 0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x65, 0x73, 0x74, 0x00, 0x0a, 0x0a, 0x0a
        }.Reverse());
        byte ReadFrame(CancellationToken cancellationToken)
        {
            return stream.Pop();
        }

        var unmarshaller = new StompUnmarshaller(NullLogger<StompDriver>.Instance);
        var frame1 = unmarshaller.Unmarshal(ReadFrame, CancellationToken.None);
        var frame2 = unmarshaller.Unmarshal(ReadFrame, CancellationToken.None);
        var frame3 = unmarshaller.Unmarshal(ReadFrame, CancellationToken.None);
        var frame4 = unmarshaller.Unmarshal(ReadFrame, CancellationToken.None);
        var frame5 = unmarshaller.Unmarshal(ReadFrame, CancellationToken.None);
        var frame6 = unmarshaller.Unmarshal(ReadFrame, CancellationToken.None);

        Assert.IsInstanceOfType(frame1, typeof(ConnectedFrame));
        Assert.IsInstanceOfType(frame2, typeof(HeartbeatFrame));
        Assert.IsInstanceOfType(frame3, typeof(ReceiptFrame));
        Assert.IsInstanceOfType(frame4, typeof(HeartbeatFrame));
        Assert.IsInstanceOfType(frame5, typeof(MessageFrame));
        Assert.IsInstanceOfType(frame6, typeof(HeartbeatFrame));
    }

    [TestMethod]
    public void Given_a_stream_with_a_connected_frame_without_version_When_unmarshalled_Than_an_error_should_be_thrown()
    {
        /*
         * MESSAGE EOL
         * destination:test EOL
         * message-id:5 EOL
         * subscription-id:a EOL
         * EOL
         * Test Test TestNULL
         */
        var stream = new Stack<byte>(new byte[]
        {
            0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x45, 0x44, 0x0a, 0x68, 0x65, 0x61, 0x72, 0x74, 0x2d, 0x62, 0x65, 0x61, 0x74, 0x3a, 0x30, 0x2c, 0x30, 0x0a, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x31, 0x0a, 0x0a, 0x00
        }.Reverse());
        byte ReadFrame(CancellationToken cancellationToken)
        {
            return stream.Count == 0 ? (byte)0x0a : stream.Pop();
        }

        var unmarshaller = new StompUnmarshaller(NullLogger<StompDriver>.Instance);
        Assert.ThrowsException<StompValidationException>(() => unmarshaller.Unmarshal(ReadFrame, CancellationToken.None));
    }

    [TestMethod]
    public void Given_a_stream_with_a_connected_frame_with_content_length_When_unmarshalled_Than_the_body_should_correctly_parsed()
    {
        /*
         * MESSAGE EOL
         * heart-beat: 0,0 EOL
         * session:1 EOL
         * content-length:4
         * EOL
         * Test Test Test
         */
        var stream = new Stack<byte>(new byte[]
        {
            0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x0a, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x74, 0x65, 0x73, 0x74, 0x0a, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2d, 0x69, 0x64, 0x3a, 0x35, 0x0a, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x2d, 0x69, 0x64, 0x3a, 0x61, 0x0a, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x34, 0x0a, 0x0a, 0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x65, 0x73, 0x74
        }.Reverse());
        byte ReadFrame(CancellationToken cancellationToken)
        {
            return stream.Count == 0 ? (byte)0x0a : stream.Pop();
        }

        var unmarshaller = new StompUnmarshaller(NullLogger<StompDriver>.Instance);
        var frame = unmarshaller.Unmarshal(ReadFrame, CancellationToken.None);
        Assert.IsInstanceOfType(frame, typeof(MessageFrame));
        Assert.AreEqual("Test", frame.GetBody());
    }
}